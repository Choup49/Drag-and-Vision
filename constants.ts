
import { Challenge, NodeDefinition, NodeType } from './types';

export const TRANSLATIONS = {
  en: {
    studio: 'Pipeline Studio',
    createNode: 'Create Node',
    challenges: 'Challenges',
    corrector: 'Code Optimizer',
    settings: 'Settings',
    library: 'Node Library',
    export: 'Export Python',
    zoomIn: 'Zoom In',
    zoomOut: 'Zoom Out',
    reset: 'Reset',
    copy: 'Copy to Clipboard',
    generated: 'Generated Python Script',
    noNodes: 'No nodes available',
    back: 'Back',
    start: 'Start Challenge',
    replay: 'Replay Challenge',
    locked: 'Locked',
    consultAI: 'Consult AI',
    aiHint: 'AI Hint',
    objectives: 'Goal',
    workspace: 'Workspace',
    openWorkspace: 'Open Editor',
    nodeName: 'Node Name',
    nodeLogic: 'Description / Logic',
    generateBtn: 'Generate & Add',
    generating: 'Generating...',
    verify: 'Verify Solution',
    verifying: 'Verifying...',
    success: 'Challenge Completed!',
    fail: 'Keep Trying',
    filterDiff: 'Difficulty',
    all: 'All',
    correctorTitle: 'Code Optimizer',
    correctorDesc: 'Optimize your Computer Vision pipeline with Gemini Intelligence.',
    pasteCode: 'Paste Python Code...',
    analyzeBtn: 'Optimize Code',
    analyzing: 'Optimizing...',
    fixedCode: 'Optimized Code',
    explanation: 'Optimization Report',
    import: 'Import Pipeline',
    importBtn: 'Import',
    saveConfig: 'Save Configuration',
    droidCamConfig: 'DroidCam Setup',
    ipAddress: 'IP Address',
    port: 'Port',
    droidCamHelp: 'Connect your phone using DroidCam IP/Port.',
    fullscreen: 'Fullscreen',
    exitFullscreen: 'Exit Fullscreen',
    createChallenge: 'Create Challenge',
    creatorMode: 'Challenge Creator',
    challengeTitle: 'Title',
    challengeDesc: 'Description',
    challengeObjs: 'Objectives (one per line)',
    saveChallenge: 'Save Challenge',
    filterTheme: 'Theme',
    classTemplate: 'Your logic here',
    genNode: 'AI Node Generator',
    manualMode: 'Manual Implementation',
    descNode: 'Describe what this node should do in plain English.',
    optimize: 'Optimize',
    cppExport: 'C++ Export',
    transpiling: 'Transpiling...',
    transpileBtn: 'Transpile to C++',
    optPreference: 'Optimization Goal',
    speed: 'Max Fluidity (FPS)',
    quality: 'High Accuracy',
    balanced: 'Balanced',
    optDescQuality: 'Prioritizes robust code, error handling, and algorithm accuracy. Slower.',
    optDescSpeed: 'Prioritizes raw execution speed, frame rate, and low latency. Less safe.',
    optDescBalanced: 'A good compromise between detection quality and real-time performance.',
    validationSuccess: 'Great job! Your pipeline produces the expected result.',
    validationFail: 'Not quite right. Check the flow and parameters.',
    retry: 'Retry',
    finish: 'Finish',
  },
  fr: {
    studio: 'Studio Pipeline',
    createNode: 'Créer un Node',
    challenges: 'Défis',
    corrector: 'Optimiseur de Code',
    settings: 'Paramètres',
    library: 'Bibliothèque',
    export: 'Exporter Python',
    zoomIn: 'Zoomer',
    zoomOut: 'Dézoomer',
    reset: 'Réinitialiser',
    copy: 'Copier',
    generated: 'Script Python Généré',
    noNodes: 'Aucun node disponible',
    back: 'Retour',
    start: 'Lancer le défi',
    replay: 'Rejouer le défi',
    locked: 'Verrouillé',
    consultAI: 'Consulter l\'IA',
    aiHint: 'Indice IA',
    objectives: 'But',
    workspace: 'Espace de travail',
    openWorkspace: 'Ouvrir l\'Éditeur',
    nodeName: 'Nom du Node',
    nodeLogic: 'Description / Logique',
    generateBtn: 'Générer et Ajouter',
    generating: 'Génération...',
    verify: 'Vérifier la Solution',
    verifying: 'Vérification...',
    success: 'Défi Réussi !',
    fail: 'Essayez encore',
    filterDiff: 'Difficulté',
    all: 'Tous',
    correctorTitle: 'Optimiseur de Code',
    correctorDesc: 'Optimisez votre pipeline Vision avec l\'IA Gemini.',
    pasteCode: 'Collez le code Python...',
    analyzeBtn: 'Optimiser le Code',
    analyzing: 'Optimisation...',
    fixedCode: 'Code Optimisé',
    explanation: 'Rapport d\'Optimisation',
    import: 'Importer Pipeline',
    importBtn: 'Importer',
    saveConfig: 'Sauvegarder Configuration',
    droidCamConfig: 'Configuration DroidCam',
    ipAddress: 'Adresse IP',
    port: 'Port',
    droidCamHelp: 'Connectez votre téléphone via l\'IP/Port de DroidCam.',
    fullscreen: 'Plein Écran',
    exitFullscreen: 'Quitter Plein Écran',
    createChallenge: 'Créer un Défi',
    creatorMode: 'Créateur de Défis',
    challengeTitle: 'Titre',
    challengeDesc: 'Description',
    challengeObjs: 'Objectifs (un par ligne)',
    saveChallenge: 'Sauvegarder le Défi',
    filterTheme: 'Thème',
    classTemplate: 'Votre logique ici',
    genNode: 'Générateur de Node IA',
    manualMode: 'Implémentation Manuelle',
    descNode: 'Décrivez ce que ce node doit faire.',
    optimize: 'Optimiser',
    cppExport: 'Export C++',
    transpiling: 'Transpilation...',
    transpileBtn: 'Transpiler en C++',
    optPreference: 'Objectif d\'Optimisation',
    speed: 'Fluidité Max (FPS)',
    quality: 'Haute Précision',
    balanced: 'Équilibré',
    optDescQuality: 'Priorise la robustesse, la gestion d\'erreurs et la précision. Plus lent.',
    optDescSpeed: 'Priorise la vitesse d\'exécution brute, les FPS et la latence. Moins sûr.',
    optDescBalanced: 'Un bon compromis entre qualité de détection et performance temps réel.',
    validationSuccess: 'Bravo ! Votre pipeline produit le résultat attendu.',
    validationFail: 'Pas tout à fait. Vérifiez le flux et les paramètres.',
    retry: 'Réessayer',
    finish: 'Terminer',
  }
};

export const AVAILABLE_NODES: NodeDefinition[] = [
  // --- CORE / SOURCES ---
  { 
    id: 'src_webcam', 
    name: 'Webcam Feed', 
    name_fr: 'Flux Webcam',
    type: NodeType.SOURCE, 
    description: 'Capture from default camera', 
    description_fr: 'Capture depuis la caméra par défaut',
    category: 'input',
    library: 'Core',
    pythonClass: 'cv2.VideoCapture',
    pythonTemplate: `# Setup\ncap = cv2.VideoCapture(0)\n# Process\nret, {output} = cap.read()\nif not ret: break`,
    requiredImports: ['cv2'],
    inputs: 0,
    outputs: 1
  },
  { 
    id: 'src_droidcam', 
    name: 'DroidCam', 
    name_fr: 'DroidCam',
    type: NodeType.SOURCE, 
    description: 'Connect via IP/Wifi', 
    description_fr: 'Connecter via IP/Wifi',
    category: 'input',
    library: 'Core',
    pythonClass: 'cv2.VideoCapture',
    pythonTemplate: `# Setup\ncap = cv2.VideoCapture("http://{ip}:{port}/video")\n# Process\nret, {output} = cap.read()\nif not ret: break`,
    requiredImports: ['cv2'],
    inputs: 0,
    outputs: 1
  },

  // --- LOGIC CONTROL ---
  {
    id: 'logic_if_face',
    name: 'If Face Detected',
    name_fr: 'Si Visage Détecté',
    type: NodeType.LOGIC,
    description: 'Branch if a face is found',
    description_fr: 'Embranchement si un visage est trouvé',
    category: 'logic',
    library: 'Logic',
    pythonClass: 'Logic',
    pythonTemplate: `if {input}_detections and len({input}_detections) > 0:`, // Special template handled by transpiler
    requiredImports: [],
    inputs: 1,
    outputs: 2 // True/False handles
  },

  // --- OPENCV TRANSFORMS ---
  {
    id: 'cv_gray',
    name: 'Grayscale',
    name_fr: 'Niveau de Gris',
    type: NodeType.PROCESS,
    description: 'Convert image to grayscale',
    description_fr: 'Convertir en niveaux de gris',
    category: 'transform',
    library: 'OpenCV',
    pythonClass: 'cv2.cvtColor',
    pythonTemplate: `{output} = cv2.cvtColor({input}, cv2.COLOR_BGR2GRAY)`,
    requiredImports: ['cv2'],
    inputs: 1,
    outputs: 1
  },
  {
    id: 'cv_blur',
    name: 'Gaussian Blur',
    name_fr: 'Flou Gaussien',
    type: NodeType.PROCESS,
    description: 'Apply soft blur filter',
    description_fr: 'Appliquer un flou doux',
    category: 'transform',
    library: 'OpenCV',
    pythonClass: 'cv2.GaussianBlur',
    pythonTemplate: `{output} = cv2.GaussianBlur({input}, (5, 5), 0)`,
    requiredImports: ['cv2'],
    inputs: 1,
    outputs: 1
  },
  {
    id: 'cv_canny',
    name: 'Canny Edges',
    name_fr: 'Contours Canny',
    type: NodeType.PROCESS,
    description: 'Detect object boundaries',
    description_fr: 'Détecter les contours',
    category: 'transform',
    library: 'OpenCV',
    pythonClass: 'cv2.Canny',
    pythonTemplate: `{output} = cv2.Canny({input}, 100, 200)`,
    requiredImports: ['cv2'],
    inputs: 1,
    outputs: 1
  },
  {
    id: 'cv_flip',
    name: 'Mirror Flip',
    name_fr: 'Effet Miroir',
    type: NodeType.PROCESS,
    description: 'Flip image horizontally',
    description_fr: 'Retourner horizontalement',
    category: 'transform',
    library: 'OpenCV',
    pythonClass: 'cv2.flip',
    pythonTemplate: `{output} = cv2.flip({input}, 1)`,
    requiredImports: ['cv2'],
    inputs: 1,
    outputs: 1
  },
  {
    id: 'cv_thresh',
    name: 'Threshold',
    name_fr: 'Seuillage',
    type: NodeType.PROCESS,
    description: 'Binary thresholding (Black/White)',
    description_fr: 'Seuillage binaire (Noir/Blanc)',
    category: 'transform',
    library: 'OpenCV',
    pythonClass: 'cv2.threshold',
    pythonTemplate: `_, {output} = cv2.threshold({input}, 127, 255, cv2.THRESH_BINARY)`,
    requiredImports: ['cv2'],
    inputs: 1,
    outputs: 1
  },
  {
    id: 'cv_hsv',
    name: 'HSV Space',
    name_fr: 'Espace HSV',
    type: NodeType.PROCESS,
    description: 'Convert BGR to HSV',
    description_fr: 'Convertir BGR vers HSV',
    category: 'transform',
    library: 'OpenCV',
    pythonClass: 'cv2.cvtColor',
    pythonTemplate: `{output} = cv2.cvtColor({input}, cv2.COLOR_BGR2HSV)`,
    requiredImports: ['cv2'],
    inputs: 1,
    outputs: 1
  },

  // --- MEDIAPIPE AI ---
  {
    id: 'mp_hands',
    name: 'Hand Tracking',
    name_fr: 'Suivi des Mains',
    type: NodeType.AI,
    description: 'MediaPipe Hand Landmark Detection',
    description_fr: 'Détection des mains avec MediaPipe',
    category: 'ai',
    library: 'MediaPipe',
    pythonClass: 'mp.solutions.hands',
    pythonTemplate: `# Setup\nimport mediapipe as mp\nmp_hands = mp.solutions.hands\nhands = mp_hands.Hands()\nmp_draw = mp.solutions.drawing_utils\n# Process\n{output} = {input}.copy()\nres = hands.process(cv2.cvtColor({input}, cv2.COLOR_BGR2RGB))\nif res.multi_hand_landmarks:\n    for lms in res.multi_hand_landmarks: mp_draw.draw_landmarks({output}, lms, mp_hands.HAND_CONNECTIONS)`,
    requiredImports: ['cv2', 'mediapipe as mp'],
    inputs: 1,
    outputs: 1
  },
  {
    id: 'mp_face_detection',
    name: 'Face Detection',
    name_fr: 'Détection Visage',
    type: NodeType.AI,
    description: 'Detect face bounding box',
    description_fr: 'Détecter le cadre du visage',
    category: 'ai',
    library: 'MediaPipe',
    pythonClass: 'mp.solutions.face_detection',
    pythonTemplate: `# Setup\nimport mediapipe as mp\nmp_face = mp.solutions.face_detection\nface_det = mp_face.FaceDetection()\nmp_draw = mp.solutions.drawing_utils\n# Process\n{output} = {input}.copy()\n{output}_detections = []\nres = face_det.process(cv2.cvtColor({input}, cv2.COLOR_BGR2RGB))\nif res.detections:\n    {output}_detections = res.detections\n    for det in res.detections: mp_draw.draw_detection({output}, det)`,
    requiredImports: ['cv2', 'mediapipe as mp'],
    inputs: 1,
    outputs: 1
  },
  {
    id: 'mp_pose',
    name: 'Pose Estimation',
    name_fr: 'Estimation de Pose',
    type: NodeType.AI,
    description: 'Full body tracking',
    description_fr: 'Suivi corporel complet',
    category: 'ai',
    library: 'MediaPipe',
    pythonClass: 'mp.solutions.pose',
    pythonTemplate: `# Setup\nimport mediapipe as mp\nmp_pose = mp.solutions.pose\npose = mp_pose.Pose()\nmp_draw = mp.solutions.drawing_utils\n# Process\n{output} = {input}.copy()\nres = pose.process(cv2.cvtColor({input}, cv2.COLOR_BGR2RGB))\nif res.pose_landmarks: mp_draw.draw_landmarks({output}, res.pose_landmarks, mp_pose.POSE_CONNECTIONS)`,
    requiredImports: ['cv2', 'mediapipe as mp'],
    inputs: 1,
    outputs: 1
  },
  {
    id: 'mp_face_mesh',
    name: 'Face Mesh',
    name_fr: 'Maillage Facial',
    type: NodeType.AI,
    description: 'High fidelity face tracking',
    description_fr: 'Suivi facial haute précision',
    category: 'ai',
    library: 'MediaPipe',
    pythonClass: 'mp.solutions.face_mesh',
    pythonTemplate: `# Setup\nimport mediapipe as mp\nmp_mesh = mp.solutions.face_mesh\nface_mesh = mp_mesh.FaceMesh()\nmp_draw = mp.solutions.drawing_utils\n# Process\n{output} = {input}.copy()\nres = face_mesh.process(cv2.cvtColor({input}, cv2.COLOR_BGR2RGB))\nif res.multi_face_landmarks:\n    for lms in res.multi_face_landmarks: mp_draw.draw_landmarks({output}, lms, mp_mesh.FACEMESH_CONTOURS)`,
    requiredImports: ['cv2', 'mediapipe as mp'],
    inputs: 1,
    outputs: 1
  },
  { 
    id: 'out_screen', 
    name: 'Display', 
    name_fr: 'Affichage',
    type: NodeType.OUTPUT, 
    description: 'Show result in window', 
    description_fr: 'Afficher dans une fenêtre',
    category: 'output',
    library: 'Core',
    pythonClass: 'cv2.imshow',
    pythonTemplate: `cv2.imshow("PyVision Output", {input})`,
    requiredImports: ['cv2'],
    inputs: 1,
    outputs: 0
  }
];

export const CHALLENGES: Challenge[] = [
  // ... (Existing Challenges Kept Same - omitted for brevity in this specific update as requested mainly for logic) ...
  // --- THEME: BASIC ---
  {
    id: 'ch_basic_easy',
    title: 'Classic Noir',
    title_fr: 'Classique Noir',
    difficulty: 'Easy',
    theme: 'Basic',
    description: 'Create a simple black and white live feed using the Grayscale node.',
    description_fr: 'Créez un flux vidéo noir et blanc simple.',
    objectives: ['Display the webcam feed in grayscale (Black & White).'],
    objectives_fr: ['Afficher le flux webcam en niveaux de gris (Noir & Blanc).'],
    locked: false
  },
  {
    id: 'ch_basic_normal',
    title: 'Neon Outlines',
    title_fr: 'Contours Néon',
    difficulty: 'Normal',
    theme: 'Basic',
    description: 'Detect edges to create a glowing neon effect on the video feed.',
    description_fr: 'Détectez les bords pour créer un effet néon sur le flux vidéo.',
    objectives: ['Display only the outlines/edges of objects seen by the camera.'],
    objectives_fr: ['Afficher uniquement les contours/bords des objets vus par la caméra.'],
    locked: false
  },
  {
    id: 'ch_basic_hard',
    title: 'Ghost Mode',
    title_fr: 'Mode Fantôme',
    difficulty: 'Hard',
    theme: 'Basic',
    description: 'Combine blurring and flipping to create a disorienting ghost effect.',
    description_fr: 'Combinez flou et retournement pour créer un effet fantôme désorientant.',
    objectives: ['Display a mirror image that is also significantly blurred.'],
    objectives_fr: ['Afficher une image miroir qui est aussi significativement floue.'],
    locked: false
  },

  // --- THEME: TRACKING ---
  {
    id: 'ch_track_easy',
    title: 'Face Box',
    title_fr: 'Boîte Visage',
    difficulty: 'Easy',
    theme: 'Tracking',
    description: 'Use AI to identify faces.',
    description_fr: 'Utilisez l\'IA pour identifier les visages.',
    objectives: ['Draw a bounding box around any detected face in the video feed.'],
    objectives_fr: ['Dessiner une boîte englobante autour de tout visage détecté dans le flux vidéo.'],
    locked: false
  },
  {
    id: 'ch_track_normal',
    title: 'Hand Skeleton',
    title_fr: 'Squelette Main',
    difficulty: 'Normal',
    theme: 'Tracking',
    description: 'Track the skeletal landmarks of your hands in real-time.',
    description_fr: 'Suivez les repères squelettiques de vos mains en temps réel.',
    objectives: ['Visualize the joints and connections of hands on the screen.'],
    objectives_fr: ['Visualiser les articulations et connexions des mains à l\'écran.'],
    locked: false
  },
  {
    id: 'ch_track_hard',
    title: 'Full Body Mesh',
    title_fr: 'Maillage Corporel',
    difficulty: 'Hard',
    theme: 'Tracking',
    description: 'Perform complex full-body pose estimation.',
    description_fr: 'Effectuez une estimation de pose complète.',
    objectives: ['Map and display the entire human body skeleton overlay.'],
    objectives_fr: ['Cartographier et afficher la superposition complète du squelette humain.'],
    locked: false
  },

  // --- THEME: SEGMENTATION ---
  {
    id: 'ch_seg_easy',
    title: 'Binary World',
    title_fr: 'Monde Binaire',
    difficulty: 'Easy',
    theme: 'Segmentation',
    description: 'Reduce the complex world to pure black and white pixels.',
    description_fr: 'Réduisez le monde complexe à des pixels purement noirs et blancs.',
    objectives: ['Create a binary image where pixels are either fully black or fully white (Thresholding).'],
    objectives_fr: ['Créer une image binaire où les pixels sont soit totalement noirs, soit totalement blancs (Seuillage).'],
    locked: false
  },
  {
    id: 'ch_seg_normal',
    title: 'Privacy Filter',
    title_fr: 'Filtre Privé',
    difficulty: 'Normal',
    theme: 'Segmentation',
    description: 'Obscure the image details for privacy.',
    description_fr: 'Masquez les détails de l\'image pour la confidentialité.',
    objectives: ['Render the video feed unrecognizable using heavy blurring.'],
    objectives_fr: ['Rendre le flux vidéo méconnaissable en utilisant un flou important.'],
    locked: false
  },
  {
    id: 'ch_seg_hard',
    title: 'Color Map',
    title_fr: 'Carte de Couleur',
    difficulty: 'Hard',
    theme: 'Segmentation',
    description: 'Visualize the image in a different color space.',
    description_fr: 'Visualisez l\'image dans un espace colorimétrique différent.',
    objectives: ['Convert and display the video in HSV color space instead of RGB.'],
    objectives_fr: ['Convertir et afficher la vidéo dans l\'espace couleur HSV au lieu de RGB.'],
    locked: false
  },

  // --- THEME: CREATIVE ---
  {
    id: 'ch_create_easy',
    title: 'Mirror Mirror',
    title_fr: 'Miroir Miroir',
    difficulty: 'Easy',
    theme: 'Creative',
    description: 'Correct the webcam orientation.',
    description_fr: 'Corrigez l\'orientation de la webcam.',
    objectives: ['Flip the video feed horizontally to act like a mirror.'],
    objectives_fr: ['Retourner le flux vidéo horizontalement pour agir comme un miroir.'],
    locked: false
  },
  {
    id: 'ch_create_normal',
    title: 'Artistic Blur',
    title_fr: 'Flou Artistique',
    difficulty: 'Normal',
    theme: 'Creative',
    description: 'Create a sketch-like effect.',
    description_fr: 'Créez un effet de croquis.',
    objectives: ['Produce an output that looks like a blurred drawing (Edges + Blur).'],
    objectives_fr: ['Produire une sortie qui ressemble à un dessin flou (Contours + Flou).'],
    locked: false
  },
  {
    id: 'ch_create_hard',
    title: 'Abstract Hands',
    title_fr: 'Mains Abstraites',
    difficulty: 'Hard',
    theme: 'Creative',
    description: 'A mind-bending experience with reversed controls.',
    description_fr: 'Une expérience troublante avec des contrôles inversés.',
    objectives: ['Display hand tracking landmarks on a mirrored video feed.'],
    objectives_fr: ['Afficher les repères de suivi des mains sur un flux vidéo en miroir.'],
    locked: false
  }
];
